<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Class: Concurrent::Promises::Channel
  
    &mdash; Concurrent Ruby
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "Concurrent::Promises::Channel";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../_index.html">Index (C)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span>
     &raquo; 
    <span class="title">Channel</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Class: Concurrent::Promises::Channel
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName"><span class='object_link'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Synchronization::Object</a></span></span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next"><span class='object_link'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Synchronization::Object</a></span></li>
          
            <li class="next">Concurrent::Promises::Channel</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>lib/concurrent-ruby-edge/concurrent/edge/channel.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p><strong>Edge Features</strong> are under active development and may change frequently.</p>

<ul>
<li>  Deprecations are not added before incompatible changes.</li>
<li>  Edge version: <em>major</em> is always 0, <em>minor</em> bump means incompatible change,
<em>patch</em> bump means compatible change.</li>
<li>  Edge features may also lack tests and documentation.</li>
<li>  Features developed in <code>concurrent-ruby-edge</code> are expected to move
to <code>concurrent-ruby</code> when finalised.</li>
</ul>
</div>
  </div>

<p>A first in first out channel that accepts messages with push family of methods and returns
messages with pop family of methods.
Pop and push operations can be represented as futures, see <span class='object_link'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">#pop_op</a></span> and <span class='object_link'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">#push_op</a></span>.
The capacity of the channel can be limited to support back pressure, use capacity option in <span class='object_link'><a href="#initialize-instance_method" title="Concurrent::Promises::Channel#initialize (method)">#initialize</a></span>.
<span class='object_link'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a></span> method blocks ans <span class='object_link'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">#pop_op</a></span> returns pending future if there is no message in the channel.
If the capacity is limited the <span class='object_link'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a></span> method blocks and <span class='object_link'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">#push_op</a></span> returns pending future.</p>

<p><h2>Examples</h2>

<p>Let&#39;s start by creating a channel with a capacity of 2 messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000002 capacity taken 0 of 2>
</span></code></pre>

<p>We push 3 messages, 
then it can be observed that the last thread pushing is sleeping 
since the channel is full. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_threads'>threads</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='label'>message:</span> <span class='id identifier rubyid_i'>i</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span> 
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'># let the threads run
</span><span class='id identifier rubyid_threads'>threads</span>
<span class='comment'># => [#<Thread:0x000003@channel.in.md:14 dead>,
</span><span class='comment'>#     #<Thread:0x000004@channel.in.md:14 dead>,
</span><span class='comment'>#     #<Thread:0x000005@channel.in.md:14 sleep_forever>]
</span></code></pre>

<p>When message is popped the last thread continues and finishes as well.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>                                   <span class='comment'># => {:message=>1}
</span><span class='id identifier rubyid_threads'>threads</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:join</span><span class='rparen'>)</span>
<span class='comment'># => [#<Thread:0x000003@channel.in.md:14 dead>,
</span><span class='comment'>#     #<Thread:0x000004@channel.in.md:14 dead>,
</span><span class='comment'>#     #<Thread:0x000005@channel.in.md:14 dead>]
</span></code></pre>

<p>Same principle applies to popping as well.
There are now 2 messages int he channel.
Lets create 3 threads trying to pop a message, 
one will be blocked until new messages is pushed.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_threads'>threads</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='rbrace'>}</span> <span class='rbrace'>}</span> 
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'># let the threads run
</span><span class='id identifier rubyid_threads'>threads</span> 
<span class='comment'># => [#<Thread:0x000006@channel.in.md:32 dead>,
</span><span class='comment'>#     #<Thread:0x000007@channel.in.md:32 dead>,
</span><span class='comment'>#     #<Thread:0x000008@channel.in.md:32 sleep_forever>]
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='label'>message:</span> <span class='int'>3</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000002 capacity taken 0 of 2>
</span><span class='id identifier rubyid_threads'>threads</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:value</span><span class='rparen'>)</span>
<span class='comment'># => [{:message=>0}, {:message=>2}, {:message=>3}]
</span></code></pre>

<h3>Promises integration</h3>

<p>However this channel is implemented to <strong>integrate with promises</strong>
therefore all operations can be represented as futures.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2>
</span><span class='id identifier rubyid_push_operations'>push_operations</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push_op'>push_op</span> <span class='label'>message:</span> <span class='id identifier rubyid_i'>i</span> <span class='rbrace'>}</span>
<span class='comment'># => [#<Concurrent::Promises::Future:0x00000a fulfilled with #<Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2>>,
</span><span class='comment'>#     #<Concurrent::Promises::Future:0x00000b fulfilled with #<Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2>>,
</span><span class='comment'>#     #<Concurrent::Promises::ResolvableFuture:0x00000c pending>]
</span></code></pre>

<blockquote>
<p>We do not have to sleep here letting the futures execute as Threads.
Since there is capacity for 2 messages the Promises are immediately resolved 
without ever allocating a Thread to execute. 
Push and pop operations are often more efficient.
The remaining pending push operation will also never require another thread,
instead it will resolve when a message is popped from the channel
making a space for a new message.    </p>
</blockquote>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                         <span class='comment'># => {:message=>0}
</span><span class='id identifier rubyid_push_operations'>push_operations</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:value!</span><span class='rparen'>)</span>
<span class='comment'># => [#<Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2>,
</span><span class='comment'>#     #<Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2>,
</span><span class='comment'>#     #<Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2>]
</span>
<span class='id identifier rubyid_pop_operations'>pop_operations</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='rbrace'>}</span>
<span class='comment'># => [#<Concurrent::Promises::ResolvableFuture:0x00000d fulfilled with {:message=>1}>,
</span><span class='comment'>#     #<Concurrent::Promises::ResolvableFuture:0x00000e fulfilled with {:message=>2}>,
</span><span class='comment'>#     #<Concurrent::Promises::ResolvableFuture:0x00000f pending>]
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='label'>message:</span> <span class='int'>3</span> <span class='comment'># (push|pop) can be freely mixed with (push_o|pop_op)
</span><span class='id identifier rubyid_pop_operations'>pop_operations</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:value</span><span class='rparen'>)</span> 
<span class='comment'># => [{:message=>1}, {:message=>2}, {:message=>3}]
</span></code></pre>

<h3>Selecting over channels</h3>

<p>A selection over channels can be created with the <code>.select_channel</code> factory method. It
will be fulfilled with a first message available in any of the channels. It
returns a pair to be able to find out which channel had the message available.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch1'>ch1</span>    <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000010 capacity taken 0 of 2>
</span><span class='id identifier rubyid_ch2'>ch2</span>    <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000011 capacity taken 0 of 2>
</span><span class='id identifier rubyid_ch1'>ch1</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>1</span> 
<span class='comment'># => #<Concurrent::Promises::Channel:0x000010 capacity taken 1 of 2>
</span><span class='id identifier rubyid_ch2'>ch2</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>2</span> 
<span class='comment'># => #<Concurrent::Promises::Channel:0x000011 capacity taken 1 of 2>
</span>
<span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_select'><span class='object_link'><a href="#select-class_method" title="Concurrent::Promises::Channel.select (method)">select</a></span></span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># => [#<Concurrent::Promises::Channel:0x000010 capacity taken 0 of 2>, 1]
</span><span class='id identifier rubyid_ch1'>ch1</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_ch2'>ch2</span><span class='rparen'>)</span>
<span class='comment'># => [#<Concurrent::Promises::Channel:0x000011 capacity taken 0 of 2>, 2]
</span>
<span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_future'><span class='object_link'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span></span> <span class='lbrace'>{</span> <span class='int'>3</span> <span class='op'>+</span> <span class='int'>4</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_then_channel_push'>then_channel_push</span><span class='lparen'>(</span><span class='id identifier rubyid_ch1'>ch1</span><span class='rparen'>)</span>
<span class='comment'># => #<Concurrent::Promises::Future:0x000012 pending>
</span><span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span> 
    <span class='comment'># or `ch1.select_op(ch2)` would be equivalent
</span>    <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>got number %03d from ch%d</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_format'>format</span><span class='op'>|</span> 
      <span class='id identifier rubyid_format'>format</span> <span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_index'>index</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_succ'>succ</span>
    <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span>                             <span class='comment'># => "got number 007 from ch1"
</span></code></pre>

<h3><code>try_</code> variants</h3>

<p>All blocking operations (<span class='object_link'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a></span>, <span class='object_link'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a></span>, <span class='object_link'><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></span>) have non-blocking variant
with <code>try_</code> prefix. 
They always return immediately and indicate either success or failure.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2>
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span> <span class='int'>1</span>                            <span class='comment'># => true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span> <span class='int'>2</span>                            <span class='comment'># => true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span> <span class='int'>3</span>                            <span class='comment'># => false
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop'>try_pop</span>                               <span class='comment'># => 1
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop'>try_pop</span>                               <span class='comment'># => 2
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop'>try_pop</span>                               <span class='comment'># => nil
</span></code></pre>

<h3>Timeouts</h3>

<p>All blocking operations (<span class='object_link'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a></span>, <span class='object_link'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a></span>, <span class='object_link'><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></span>) have a timeout option.
Similar to <code>try_</code> variants it will indicate success or timing out, 
when the timeout option is used.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2>
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>1</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># => true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>2</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># => true
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='int'>3</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># => false
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='float'>0.01</span>                              <span class='comment'># => 1
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='float'>0.01</span>                              <span class='comment'># => 2
</span><span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='float'>0.01</span>                              <span class='comment'># => nil
</span></code></pre>

<h3>Backpressure</h3>

<p>Most importantly the channel can be used to create systems with backpressure.
A self adjusting system where the producers will slow down 
if the consumers are not keeping up.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000013 capacity taken 0 of 2>
</span><span class='id identifier rubyid_log'>log</span>     <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span>          <span class='comment'># => []
</span>
<span class='id identifier rubyid_producers'>producers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span> <span class='int'>2</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='int'>4</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_j'>j</span><span class='op'>|</span>
      <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>"</span><span class='tstring_content'>producer %d pushing %d</span><span class='tstring_end'>"</span></span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span>      
      <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='lbracket'>[</span><span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span><span class='rbracket'>]</span>      
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'># => [#<Thread:0x000014@channel.in.md:133 run>,
</span><span class='comment'>#     #<Thread:0x000015@channel.in.md:133 run>]
</span>
<span class='id identifier rubyid_consumers'>consumers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span> <span class='int'>4</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_consumer'>consumer</span><span class='op'>|</span>
    <span class='int'>2</span><span class='period'>.</span><span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_j'>j</span><span class='op'>|</span>
      <span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>
      <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>"</span><span class='tstring_content'>consumer %d got %d. payload %d from producer %d</span><span class='tstring_end'>"</span></span><span class='comma'>,</span> 
                      <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_from'>from</span>       
      <span class='id identifier rubyid_do_stuff'>do_stuff</span>      
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'># => [#<Thread:0x000016@channel.in.md:142 run>,
</span><span class='comment'>#     #<Thread:0x000017@channel.in.md:142 run>,
</span><span class='comment'>#     #<Thread:0x000018@channel.in.md:142 run>,
</span><span class='comment'>#     #<Thread:0x000019@channel.in.md:142 run>]
</span>
<span class='comment'># wait for all to finish
</span><span class='id identifier rubyid_producers'>producers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:join</span><span class='rparen'>)</span>
<span class='comment'># => [#<Thread:0x000014@channel.in.md:133 dead>,
</span><span class='comment'>#     #<Thread:0x000015@channel.in.md:133 dead>]
</span><span class='id identifier rubyid_consumers'>consumers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:join</span><span class='rparen'>)</span>
<span class='comment'># => [#<Thread:0x000016@channel.in.md:142 dead>,
</span><span class='comment'>#     #<Thread:0x000017@channel.in.md:142 dead>,
</span><span class='comment'>#     #<Thread:0x000018@channel.in.md:142 dead>,
</span><span class='comment'>#     #<Thread:0x000019@channel.in.md:142 dead>]
</span><span class='comment'># investigate log
</span><span class='id identifier rubyid_log'>log</span>
<span class='comment'># => ["producer 0 pushing 0",
</span><span class='comment'>#     "producer 0 pushing 1",
</span><span class='comment'>#     "producer 0 pushing 2",
</span><span class='comment'>#     "producer 1 pushing 0",
</span><span class='comment'>#     "consumer 0 got 0. payload 0 from producer 0",
</span><span class='comment'>#     "producer 0 pushing 3",
</span><span class='comment'>#     "consumer 1 got 0. payload 1 from producer 0",
</span><span class='comment'>#     "consumer 2 got 0. payload 2 from producer 0",
</span><span class='comment'>#     "consumer 3 got 0. payload 0 from producer 1",
</span><span class='comment'>#     "producer 1 pushing 1",
</span><span class='comment'>#     "producer 1 pushing 2",
</span><span class='comment'>#     "consumer 1 got 1. payload 3 from producer 0",
</span><span class='comment'>#     "producer 1 pushing 3",
</span><span class='comment'>#     "consumer 2 got 1. payload 1 from producer 1",
</span><span class='comment'>#     "consumer 3 got 1. payload 2 from producer 1",
</span><span class='comment'>#     "consumer 0 got 1. payload 3 from producer 1"]
</span></code></pre>

<p>The producers are much faster than consumers 
(since they <code>do_stuff</code> which takes some time)<br>
but as it can be seen from the log they fill the channel 
and then they slow down 
until there is space available in the channel.</p>

<p>If permanent allocation of threads to the producers and consumers has to be avoided,
the threads can be replaced with promises
that run a thread pool.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>2</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x00001a capacity taken 0 of 2>
</span><span class='id identifier rubyid_log'>log</span>     <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span>          <span class='comment'># => []
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_produce'>produce</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>"</span><span class='tstring_content'>producer %d pushing %d</span><span class='tstring_end'>"</span></span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>      
  <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push_op'>push_op</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span> <span class='op'><</span> <span class='int'>4</span> <span class='op'>?</span> <span class='id identifier rubyid_produce'>produce</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span><span class='rparen'>)</span> <span class='op'>:</span> <span class='symbol'>:done</span>    
  <span class='kw'>end</span>      
<span class='kw'>end</span>                                      <span class='comment'># => :produce
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_consume'>consume</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span><span class='lparen'>(</span><span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='id identifier rubyid_log'>log</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>"</span><span class='tstring_content'>consumer %d got %d. payload %d from producer %d</span><span class='tstring_end'>"</span></span><span class='comma'>,</span> 
                    <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_from'>from</span>       
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span> <span class='op'><</span> <span class='int'>2</span> <span class='op'>?</span> <span class='id identifier rubyid_consume'>consume</span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span><span class='rparen'>)</span> <span class='op'>:</span> <span class='symbol'>:done</span>       
  <span class='kw'>end</span>
<span class='kw'>end</span>                                      <span class='comment'># => :consume
</span>
<span class='id identifier rubyid_producers'>producers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span> <span class='int'>2</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_future'><span class='object_link'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span> <span class='id identifier rubyid_produce'>produce</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='int'>0</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># => [#<Concurrent::Promises::Future:0x00001b pending>,
</span><span class='comment'>#     #<Concurrent::Promises::Future:0x00001c pending>]
</span>
<span class='id identifier rubyid_consumers'>consumers</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span></span> <span class='int'>4</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_future'><span class='object_link'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span> <span class='id identifier rubyid_consume'>consume</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='int'>0</span> <span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'># => [#<Concurrent::Promises::Future:0x00001d pending>,
</span><span class='comment'>#     #<Concurrent::Promises::Future:0x00001e pending>,
</span><span class='comment'>#     #<Concurrent::Promises::Future:0x00001f pending>,
</span><span class='comment'>#     #<Concurrent::Promises::Future:0x000020 pending>]
</span>
<span class='comment'># wait for all to finish
</span><span class='id identifier rubyid_producers'>producers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:value!</span><span class='rparen'>)</span>                  <span class='comment'># => [:done, :done]
</span><span class='id identifier rubyid_consumers'>consumers</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&</span><span class='symbol'>:value!</span><span class='rparen'>)</span>                  <span class='comment'># => [:done, :done, :done, :done]
</span><span class='comment'># investigate log
</span><span class='id identifier rubyid_log'>log</span>
<span class='comment'># => ["producer 0 pushing 0",
</span><span class='comment'>#     "producer 1 pushing 0",
</span><span class='comment'>#     "producer 1 pushing 1",
</span><span class='comment'>#     "consumer 1 got 0. payload 0 from producer 1",
</span><span class='comment'>#     "consumer 2 got 0. payload 1 from producer 1",
</span><span class='comment'>#     "producer 0 pushing 1",
</span><span class='comment'>#     "producer 0 pushing 2",
</span><span class='comment'>#     "producer 0 pushing 3",
</span><span class='comment'>#     "producer 1 pushing 2",
</span><span class='comment'>#     "consumer 0 got 0. payload 0 from producer 0",
</span><span class='comment'>#     "consumer 3 got 0. payload 1 from producer 0",
</span><span class='comment'>#     "producer 1 pushing 3",
</span><span class='comment'>#     "consumer 2 got 1. payload 2 from producer 0",
</span><span class='comment'>#     "consumer 1 got 1. payload 3 from producer 0",
</span><span class='comment'>#     "consumer 3 got 1. payload 3 from producer 1",
</span><span class='comment'>#     "consumer 0 got 1. payload 2 from producer 1"]
</span></code></pre>

<h3>Synchronization of workers by passing a value</h3>

<p>If the capacity of the channel is zero 
then any push operation will succeed only 
when there is a matching pop operation
which can take the message.
The operations have to be paired to succeed. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='op'>::</span><span class='const'>Channel</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='int'>0</span>
<span class='comment'># => #<Concurrent::Promises::Channel:0x000021 capacity taken 0 of 0>
</span><span class='id identifier rubyid_thread'>thread</span> <span class='op'>=</span> <span class='const'>Thread</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span> <span class='rbrace'>}</span><span class='semicolon'>;</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> 
<span class='comment'># allow the thread to go to sleep
</span><span class='id identifier rubyid_thread'>thread</span>
<span class='comment'># => #<Thread:0x000022@channel.in.md:214 sleep_forever>
</span><span class='comment'># succeeds because there is matching pop operation waiting in the thread 
</span><span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_try_push'>try_push</span><span class='lparen'>(</span><span class='symbol'>:v1</span><span class='rparen'>)</span>                    <span class='comment'># => true
</span><span class='comment'># remains pending, since there is no matching operation 
</span><span class='id identifier rubyid_push'>push</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_push_op'>push_op</span><span class='lparen'>(</span><span class='symbol'>:v2</span><span class='rparen'>)</span>
<span class='comment'># => #<Concurrent::Promises::ResolvableFuture:0x000023 pending>
</span><span class='id identifier rubyid_thread'>thread</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>                             <span class='comment'># => :v1
</span><span class='comment'># the push operation resolves as a pairing pop is called
</span><span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop'>pop</span>                              <span class='comment'># => :v2
</span><span class='id identifier rubyid_push'>push</span>
<span class='comment'># => #<Concurrent::Promises::ResolvableFuture:0x000023 fulfilled with #<Concurrent::Promises::Channel:0x000021 capacity taken 0 of 0>>
</span></code></pre>
</p>


  </div>
</div>
<div class="tags">
  

</div>
  
    <h2>
      Constant Summary
      <small><a href="#" class="constants_summary_toggle">collapse</a></small>
    </h2>

    <dl class="constants">
      
        <dt id="UNLIMITED_CAPACITY-constant" class="">UNLIMITED_CAPACITY =
          <div class="docstring">
  <div class="discussion">
    <p>Default capacity of the Channel, makes it accept unlimited number of messages.</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='op'>::</span><span class='const'>Object</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span></pre></dd>
      
        <dt id="ANY-constant" class="">ANY =
          <div class="docstring">
  <div class="discussion">
    <p>An object which matches anything (with #===)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>Object</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_any'>any</span><span class='op'>|</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_any'>any</span><span class='period'>.</span><span class='op'>===</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_any'>any</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
    <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ANY</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre></dd>
      
    </dl>
  







  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-class_method" title="select (class method)">.<strong>select</strong>(channels, timeout = nil)  &#x21d2; ::Array(Channel, Object), nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_matching-class_method" title="select_matching (class method)">.<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; ::Array(Channel, Object), nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_op-class_method" title="select_op (class method)">.<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; Future(::Array(Channel, Object)) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_op_matching-class_method" title="select_op_matching (class method)">.<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; Future(::Array(Channel, Object)) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_select-class_method" title="try_select (class method)">.<strong>try_select</strong>(channels)  &#x21d2; ::Array(Channel, Object) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_select_matching-class_method" title="try_select_matching (class method)">.<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; ::Array(Channel, Object) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#capacity-instance_method" title="#capacity (instance method)">#<strong>capacity</strong>  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Maximum capacity of the Channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">#<strong>initialize</strong>(capacity = UNLIMITED_CAPACITY)  &#x21d2; Channel </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Create channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#peek-instance_method" title="#peek (instance method)">#<strong>peek</strong>(no_value = nil)  &#x21d2; Object, no_value </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Behaves as <span class='object_link'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a></span> but it does not remove the message from the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#peek_matching-instance_method" title="#peek_matching (instance method)">#<strong>peek_matching</strong>(matcher, no_value = nil)  &#x21d2; Object, no_value </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Behaves as <span class='object_link'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a></span> but it does not remove the message from the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop-instance_method" title="#pop (instance method)">#<strong>pop</strong>(timeout = nil, timeout_value = nil)  &#x21d2; Object, nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Blocks current thread until a message is available in the channel for popping.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop_matching-instance_method" title="#pop_matching (instance method)">#<strong>pop_matching</strong>(matcher, timeout = nil, timeout_value = nil)  &#x21d2; Object, nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Blocks current thread until a message is available in the channel for popping.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop_op-instance_method" title="#pop_op (instance method)">#<strong>pop_op</strong>(probe = Promises.resolvable_future)  &#x21d2; Future(Object) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a future witch will become fulfilled with a value from the channel when one is available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop_op_matching-instance_method" title="#pop_op_matching (instance method)">#<strong>pop_op_matching</strong>(matcher, probe = Promises.resolvable_future)  &#x21d2; Future(Object) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a future witch will become fulfilled with a value from the channel when one is available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#push-instance_method" title="#push (instance method)">#<strong>push</strong>(message, timeout = nil)  &#x21d2; self, true, false </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Blocks current thread until the message is pushed into the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#push_op-instance_method" title="#push_op (instance method)">#<strong>push_op</strong>(message)  &#x21d2; ResolvableFuture(self) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns future which will fulfill when the message is pushed to the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-instance_method" title="#select (instance method)">#<strong>select</strong>(channels, timeout = nil)  &#x21d2; ::Array(Channel, Object), nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>As <span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_matching-instance_method" title="#select_matching (instance method)">#<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; ::Array(Channel, Object), nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>As <span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_op-instance_method" title="#select_op (instance method)">#<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; ResolvableFuture(::Array(Channel, Object)) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select_op_matching-instance_method" title="#select_op_matching (instance method)">#<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; ResolvableFuture(::Array(Channel, Object)) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#size-instance_method" title="#size (instance method)">#<strong>size</strong>  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The number of messages currently stored in the channel.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  &#x21d2; String </a>
    

    
      (also: #inspect)
    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Short string representation.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_pop-instance_method" title="#try_pop (instance method)">#<strong>try_pop</strong>(no_value = nil)  &#x21d2; Object, no_value </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Pop a message from the channel if there is one available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_pop_matching-instance_method" title="#try_pop_matching (instance method)">#<strong>try_pop_matching</strong>(matcher, no_value = nil)  &#x21d2; Object, no_value </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Pop a message from the channel if there is one available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_push-instance_method" title="#try_push (instance method)">#<strong>try_push</strong>(message)  &#x21d2; true, false </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Push the message into the channel if there is space available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_select-instance_method" title="#try_select (instance method)">#<strong>try_select</strong>(channels)  &#x21d2; ::Array(Channel, Object), nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>If message is available in the receiver or any of the provided channels the channel message pair is returned.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_select_matching-instance_method" title="#try_select_matching (instance method)">#<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; ::Array(Channel, Object), nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>If message is available in the receiver or any of the provided channels the channel message pair is returned.</p>
</div></span>
  
</li>

      
    </ul>
  


  
  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    #<strong>initialize</strong>(capacity = UNLIMITED_CAPACITY)  &#x21d2; <tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Create channel.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>capacity</span>
      
      
        <span class='type'>(<tt>Integer</tt>, <tt><span class='object_link'><a href="#UNLIMITED_CAPACITY-constant" title="Concurrent::Promises::Channel::UNLIMITED_CAPACITY (constant)">UNLIMITED_CAPACITY</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>UNLIMITED_CAPACITY</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum number of messages which can be stored in the channel.</p>
</div>
      
    </li>
  
</ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


61
62
63
64
65
66
67
68
69</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 61</span>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_capacity'>capacity</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="#UNLIMITED_CAPACITY-constant" title="Concurrent::Promises::Channel::UNLIMITED_CAPACITY (constant)">UNLIMITED_CAPACITY</a></span></span><span class='rparen'>)</span>
  <span class='kw'>super</span><span class='lparen'>(</span><span class='rparen'>)</span>
  <span class='ivar'>@Capacity</span> <span class='op'>=</span> <span class='id identifier rubyid_capacity'>capacity</span>
  <span class='ivar'>@Mutex</span>    <span class='op'>=</span> <span class='const'>Mutex</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
  <span class='comment'># TODO (pitr-ch 28-Jan-2019): consider linked lists or other data structures for following attributes, things are being deleted from the middle
</span>  <span class='ivar'>@Probes</span>      <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
  <span class='ivar'>@Messages</span>    <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
  <span class='ivar'>@PendingPush</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="select-class_method">
  
    .<strong>select</strong>(channels, timeout = nil)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


319
320
321</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 319</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_matching-class_method">
  
    .<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_matching-instance_method" title="Concurrent::Promises::Channel#select_matching (method)">#select_matching</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


337
338
339</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 337</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_matching'>select_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_select_matching'>select_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_op-class_method">
  
    .<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


313
314
315</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 313</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_op_matching-class_method">
  
    .<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_op_matching-instance_method" title="Concurrent::Promises::Channel#select_op_matching (method)">#select_op_matching</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


331
332
333</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 331</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op_matching'>select_op_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_select_op_matching'>select_op_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_select-class_method">
  
    .<strong>try_select</strong>(channels)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#try_select-instance_method" title="Concurrent::Promises::Channel#try_select (method)">#try_select</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


307
308
309</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 307</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select'>try_select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_try_select'>try_select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_select_matching-class_method">
  
    .<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>)</span>
      
      
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#try_select_matching-instance_method" title="Concurrent::Promises::Channel#try_select_matching (method)">#try_select_matching</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


325
326
327</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 325</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select_matching'>try_select_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_channels'>channels</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='period'>.</span><span class='id identifier rubyid_try_select_matching'>try_select_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='lbracket'>[</span><span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="capacity-instance_method">
  
    #<strong>capacity</strong>  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns Maximum capacity of the Channel.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Maximum capacity of the Channel.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


292
293
294</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 292</span>

<span class='kw'>def</span> <span class='id identifier rubyid_capacity'>capacity</span>
  <span class='ivar'>@Capacity</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="peek-instance_method">
  
    #<strong>peek</strong>(no_value = nil)  &#x21d2; <tt>Object</tt>, <tt>no_value</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Behaves as <span class='object_link'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a></span> but it does not remove the message from the channel</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>no_value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>returned when there is no message available</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>no_value</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when there is no message</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


206
207
208</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 206</span>

<span class='kw'>def</span> <span class='id identifier rubyid_peek'>peek</span><span class='lparen'>(</span><span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_peek_matching'>peek_matching</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="peek_matching-instance_method">
  
    #<strong>peek_matching</strong>(matcher, no_value = nil)  &#x21d2; <tt>Object</tt>, <tt>no_value</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Behaves as <span class='object_link'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a></span> but it does not remove the message from the channel</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>no_value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>returned when there is no message available</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>no_value</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when there is no message</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


212
213
214
215
216
217
218
219</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 212</span>

<span class='kw'>def</span> <span class='id identifier rubyid_peek_matching'>peek_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'>ns_shift_message</span> <span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='kw'>false</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span> <span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='kw'>false</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span> <span class='op'>?</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>:</span> <span class='id identifier rubyid_no_value'>no_value</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pop-instance_method">
  
    #<strong>pop</strong>(timeout = nil, timeout_value = nil)  &#x21d2; <tt>Object</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>Blocks current thread until a message is available in the channel for popping.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>timeout_value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>a value returned by the method when it times out</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when timed out</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


174
175
176</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 174</span>

<span class='kw'>def</span> <span class='id identifier rubyid_pop'>pop</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_pop_matching'>pop_matching</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pop_matching-instance_method">
  
    #<strong>pop_matching</strong>(matcher, timeout = nil, timeout_value = nil)  &#x21d2; <tt>Object</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>Blocks current thread until a message is available in the channel for popping.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>timeout_value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>a value returned by the method when it times out</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when timed out</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 180</span>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_matching'>pop_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='comment'># TODO (pitr-ch 27-Jan-2019): should it try to match pending pushes if it fails to match in the buffer? Maybe only if the size is zero. It could be surprising if it&#39;s used as a throttle it might be expected that it will not pop if buffer is full of messages which di not match, it might it expected it will block until the message is added to the buffer
</span>  <span class='comment'># that it returns even if the buffer is full. User might expect that it has to be in the buffer first.
</span>  <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'>ns_shift_message</span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>==</span> <span class='const'>NOTHING</span>
      <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span> <span class='id identifier rubyid_matcher'>matcher</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span>
      <span class='ivar'>@Messages</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='kw'>unless</span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>==</span> <span class='const'>NOTHING</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span>
    <span class='ivar'>@Probes</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='id identifier rubyid_probe'>probe</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_probe'>probe</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='kw'>true</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pop_op-instance_method">
  
    #<strong>pop_op</strong>(probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(Object)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a future witch will become fulfilled with a value from the channel when one is available.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>probe</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>Promises.resolvable_future</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the future which will be fulfilled with a channel value</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(Object)</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the probe, its value will be the message when available.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


157
158
159</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 157</span>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='lparen'>(</span><span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ns_pop_op'>ns_pop_op</span><span class='lparen'>(</span><span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="pop_op_matching-instance_method">
  
    #<strong>pop_op_matching</strong>(matcher, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(Object)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a future witch will become fulfilled with a value from the channel when one is available.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>probe</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>Promises.resolvable_future</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the future which will be fulfilled with a channel value</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a></span>(Object)</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>the probe, its value will be the message when available.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


163
164
165</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 163</span>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_op_matching'>pop_op_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ns_pop_op'>ns_pop_op</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="push-instance_method">
  
    #<strong>push</strong>(message, timeout = nil)  &#x21d2; <tt>self</tt>, <tt>true</tt>, <tt>false</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>Blocks current thread until the message is pushed into the channel.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>message</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>self</tt>, <tt>true</tt>, <tt>false</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>self implies timeout was not used, true implies timeout was used
and it was pushed, false implies it was not pushed within timeout.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


117
118
119
120
121
122
123
124
125
126
127
128
129</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 117</span>

<span class='kw'>def</span> <span class='id identifier rubyid_push'>push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_pushed_op'>pushed_op</span> <span class='op'>=</span> <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>?</span> <span class='kw'>true</span> <span class='op'>:</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>

    <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span>
    <span class='comment'># TODO (pitr-ch 06-Jan-2019): clear timed out pushes in @PendingPush, null messages
</span>    <span class='ivar'>@PendingPush</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span>
    <span class='id identifier rubyid_pushed'>pushed</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='id identifier rubyid_pushed_op'>pushed_op</span><span class='period'>.</span><span class='id identifier rubyid_wait!'>wait!</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>self</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_result'>result</span> <span class='op'>==</span> <span class='id identifier rubyid_pushed_op'>pushed_op</span> <span class='op'>?</span> <span class='kw'>self</span> <span class='op'>:</span> <span class='id identifier rubyid_result'>result</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="push_op-instance_method">
  
    #<strong>push_op</strong>(message)  &#x21d2; <tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(self)</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns future which will fulfill when the message is pushed to the channel.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>message</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(self)</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


98
99
100
101
102
103
104
105
106
107
108</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 98</span>

<span class='kw'>def</span> <span class='id identifier rubyid_push_op'>push_op</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
      <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_fulfilled_future'><span class='object_link'><a href="FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span></span> <span class='kw'>self</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span>
      <span class='ivar'>@PendingPush</span><span class='period'>.</span><span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_pushed'>pushed</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select-instance_method">
  
    #<strong>select</strong>(channels, timeout = nil)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>As <span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span> but does not return future,
it block current thread instead until there is a message available
in the receiver or in any of the channels.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when timed out</p>
</div>
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


275
276
277</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 275</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_select_matching'>select_matching</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_matching-instance_method">
  
    #<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>This function potentially blocks current thread until it can continue.
Be careful it can deadlock.</p>
</div>
  </div>

<p>As <span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span> but does not return future,
it block current thread instead until there is a message available
in the receiver or in any of the channels.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>timeout</span>
      
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the maximum time in second to wait.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when timed out</p>
</div>
      
    </li>
  
</ul>

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


281
282
283
284</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 281</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_matching'>select_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='id identifier rubyid_select_op_matching'>select_op_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_probe'>probe</span><span class='period'>.</span><span class='id identifier rubyid_value!'>value!</span><span class='lparen'>(</span><span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_op-instance_method">
  
    #<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>When message is available in the receiver or any of the provided channels
the future is fulfilled with a channel message pair.
The returned channel is the origin of the message.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>probe</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>Promises.resolvable_future</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the future which will be fulfilled with the message</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a future which is fulfilled with
pair [channel, message] when one of the channels is available for reading</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


254
255
256</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 254</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op'>select_op</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_select_op_matching'>select_op_matching</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="select_op_matching-instance_method">
  
    #<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; <tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>When message is available in the receiver or any of the provided channels
the future is fulfilled with a channel message pair.
The returned channel is the origin of the message.
If it is later waited on the operation with a timeout e.g.<code>channel.pop_op.wait(1)</code>
it will not prevent the channel to fulfill the operation later after the timeout.
The operation has to be either processed later</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span><span class='period'>.</span><span class='id identifier rubyid_pop_op'>pop_op</span>
<span class='kw'>if</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_wait'>wait</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_value'>value</span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_pop_op'>pop_op</span><span class='period'>.</span><span class='id identifier rubyid_then'>then</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>or the operation can be prevented from completion after timing out by using
<code>channel.pop_op.wait(1, [true, nil, nil])</code>.
It will fulfill the operation on timeout preventing channel from doing the operation,
e.g. popping a message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>probe</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>Promises.resolvable_future</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>the future which will be fulfilled with the message</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a></span>(::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object))</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a future which is fulfilled with
pair [channel, message] when one of the channels is available for reading</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


260
261
262
263</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 260</span>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op_matching'>select_op_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span></span><span class='period'>.</span><span class='id identifier rubyid_resolvable_future'><span class='object_link'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></span><span class='rparen'>)</span>
  <span class='lbracket'>[</span><span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_channels'>channels</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_ch'>ch</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_partial_select_op'>partial_select_op</span> <span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_probe'>probe</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="size-instance_method">
  
    #<strong>size</strong>  &#x21d2; <tt>Integer</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns The number of messages currently stored in the channel.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>The number of messages currently stored in the channel.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


287
288
289</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 287</span>

<span class='kw'>def</span> <span class='id identifier rubyid_size'>size</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='ivar'>@Messages</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="to_s-instance_method">
  
    #<strong>to_s</strong>  &#x21d2; <tt>String</tt> 
  

  
    <span class="aliases">Also known as:
    <span class="names"><span id='inspect-instance_method'>inspect</span></span>
    </span>
  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns Short string representation.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Short string representation.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


297
298
299</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 297</span>

<span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
  <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>%s capacity taken %s of %s&gt;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>super</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_size'>size</span><span class='comma'>,</span> <span class='ivar'>@Capacity</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_pop-instance_method">
  
    #<strong>try_pop</strong>(no_value = nil)  &#x21d2; <tt>Object</tt>, <tt>no_value</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Pop a message from the channel if there is one available.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>no_value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>returned when there is no message available</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>no_value</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when there is no message</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


135
136
137</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 135</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_pop'>try_pop</span><span class='lparen'>(</span><span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_try_pop_matching'>try_pop_matching</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_pop_matching-instance_method">
  
    #<strong>try_pop_matching</strong>(matcher, no_value = nil)  &#x21d2; <tt>Object</tt>, <tt>no_value</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Pop a message from the channel if there is one available.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>no_value</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>nil</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>returned when there is no message available</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Object</tt>, <tt>no_value</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>message or nil when there is no message</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


142
143
144
145
146
147
148
149</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 142</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_pop_matching'>try_pop_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'>ns_shift_message</span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span> <span class='op'>?</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>:</span> <span class='id identifier rubyid_no_value'>no_value</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_push-instance_method">
  
    #<strong>try_push</strong>(message)  &#x21d2; <tt>true</tt>, <tt>false</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Push the message into the channel if there is space available.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>message</span>
      
      
        <span class='type'>(<tt>Object</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>true</tt>, <tt>false</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


74
75
76</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 74</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_push'>try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span>
  <span class='ivar'>@Mutex</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span><span class='lparen'>(</span><span class='id identifier rubyid_message'>message</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_select-instance_method">
  
    #<strong>try_select</strong>(channels)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>If message is available in the receiver or any of the provided channels
the channel message pair is returned. If there is no message nil is returned.
The returned channel is the origin of the message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>pair [channel, message] if one of the channels is available for reading</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


229
230
231</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 229</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select'>try_select</span><span class='lparen'>(</span><span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_try_select_matching'>try_select_matching</span> <span class='const'><span class='object_link'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span></span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_select_matching-instance_method">
  
    #<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; <tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>If message is available in the receiver or any of the provided channels
the channel message pair is returned. If there is no message nil is returned.
The returned channel is the origin of the message.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>channels</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span></tt>, <tt>::Array&lt;<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>matcher</span>
      
      
        <span class='type'>(<tt>#===</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>only consider message which matches <code>matcher === a_message</code></p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>::Array(<span class='object_link'><a href="" title="Concurrent::Promises::Channel (class)">Channel</a></span>, Object)</tt>, <tt>nil</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>pair [channel, message] if one of the channels is available for reading</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


235
236
237
238
239
240
241
242</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 235</span>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select_matching'>try_select_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='kw'>nil</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_channels'>channels</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ch'>ch</span><span class='op'>|</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ch'>ch</span><span class='period'>.</span><span class='id identifier rubyid_try_pop_matching'>try_pop_matching</span><span class='lparen'>(</span><span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='const'>NOTHING</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'>NOTHING</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>?</span> <span class='lbracket'>[</span><span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='rbracket'>]</span> <span class='op'>:</span> <span class='kw'>nil</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated by <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_blank">yard</a>.
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57940973-1', 'auto');
  ga('send', 'pageview');

</script>

    </div>
  </body>
</html>